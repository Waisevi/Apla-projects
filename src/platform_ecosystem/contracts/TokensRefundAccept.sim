contract TokensRefundAccept{
    data{
        Id string
    }
    func closeNotes(){
        var notes array
        notes = DBFind("notifications").Where({page_name:"voting_view", "page_params->voting_id":$votingID})
        var i int
        while i < Len(notes){
            var note map
            note = notes[i]
            var noteId int
            noteId = Int(note["id"])
            NotificationsClose("notific_id", noteId)
            i=i+1
        }
    }
    func refundAmount(victimId, attackerId, amount string){
        TokensRefund("SenderId,RecipientId,Amount", attackerId, victimId, amount)
    }
    func unblockAccounts(victimId, attackerId string){
        if victimId==0 {
            error "unblockAccounts. invalid victim key"
        }
        if attackerId==0{
            error "unblockAccounts. invalid attacker key"
        }
        DBUpdate("keys", Int(victimId), {blocked:0})
        DBUpdate("keys", Int(attackerId), {blocked:0})
    }

    conditions{
        $Id = Int($Id)
        $tokenrefund = DBFind("tokenrefund").WhereId($Id).Row()
        if !$tokenrefund{
            error "tokenrefund not found"
        }
        $votingID = $tokenrefund["voting_id"]
    }

    action{
        unblockAccounts($tokenrefund["victim_key_id"],$tokenrefund["attacker_key_id"])
        closeNotes()
        if $tokenrefund["result"] == 2 || $tokenrefund["status"] == 3{
            return
        }
        refundAmount($tokenrefund["victim_key_id"],$tokenrefund["attacker_key_id"],$tokenrefund["amount"])
        // status 3: closed; result 2: the tokens returned
        DBUpdate("tokenrefund", $Id, {status:3, result:2})
    }
}